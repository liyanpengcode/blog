<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F29%2Fjava%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[[TOC] 并发简史在过去,计算机只有一个CPU,并且只能执行一个程序.后来出现多任务处理,可以同时处理执行多个任务程序.然而实际上它并不是”同一时间执行”,而是随着时间片切换执行. 随着多任务处理,只能满足计算机可以处理运行多个应用程序能力,并没有实现程序多线程的处理能力,导致程序性能不好. 后来出现程序多线程,也就是同一程序在CPU执行同时,可以在CPU执行程序同事间段处理多个任务线程,提高了程序的执行效率. 随着计算机的发展出现多核CPU处理器,这就意味着应用程序可以在单独核心或者CPU同时执行多个单独的线程. 图1-1 多线程的好处 提高CPU资源利用率 提高程序的响应速度. 在大量使用io时可以更好的设计程序,让程序进入后台处理,有效避免阻塞出现; 避免单个线程阻塞导致整个程序阻塞. 多线程的坏处 程序由单一的线程,变成多个线程对象,从时间的角度虽然变快了,但是从空间的角度反而更占内存空间了,共享数据的交互的成本变高了; 操作系统的上下文开销也会随着提高,当CPU线程A切换至线程B时,CPU需要保存当前线程的本地数据,程序指针,并加载B线程的本地数据,切换指针并执行 增加了程序的复杂性,同时操作系统也要分配和维护相应的(操作系统)资源; 总结我们考虑多线程主要从时间,和空间的角度去思考,补充一点根据具体的业务场景使用; 并发模型什么是并发模型? 并发模型指的是程序线程如何协作完成程序给的任务; 并发可以使用不同的并发模型来实现,不同的并发模型使用不同的方式进行通信,协作; 并行工人 在并行工人模型中,委托者加任务分配给不同的工人者,这些并行工作,在不同线程中运行,如果在多核CPU计算机中也许会在不同CPU上运行; 并行工人的优点:提高程序的代码的并行化,创建跟多的任务程序(Thread) 并行工人的缺点:无法保证那个线程先执行或者是最后执行; 这样就导致并行模型先后执行变得困难; 注释:[java.util.concurrent] java 包中很多并发使用程序都和并行工人模型一起使用而设计的. 共享状态模型 共享状态进入并行工人模型,线程需要一种方式访问共享数据,以确保线程更改数据对其他线程可见,线程要避免竞争,死锁和其他共享状态的问题 此时,部分并行操作将消失,因为许多并发数据结构都是阻塞的 共享状态可以由系统中的其他线程修改,所以线程必须每次执行时都需要重新阅读共享状态,不管是否存在内存中还是数据库中; 装配线并发模型流水线:也称工厂模型 由上图可见装配线并发模型:就像流水线工人一样,每个工人各司其职只完成自己对应的任务,剩下的继续传递下一位工人; 一般适用于多io操作:io线程于io线程之间的传递就不用阻塞,等待CPU执行; 频道模型在频道模型中工人之间不直接沟通,而是通过频道传递消息,相应的通道员工监听该通道信息; 好处; 降低了耦合度; 取消和订阅变得简单; 获取数据运行状态日志变得容易; 缺点: 装配线并发模型,通常在多个worker上,具体很难确定在哪块代码中执行; 出现回调函数轮回,很容易产逻辑处理错误; 功能并行模型 函数并行模型: 使用函数调用实现程序,类似流水线并发模型和; Java7 java.util.concurrent包含ForkAndJoinPool的包功能十分类似; Java8 可以直接获取并行流,实际上并行流就是使用多线程处理; 优点: 如果计算机多核CPU处理器,并且该功能函数并行模型过长/或很大.且计算机只服务该服务,可以考虑使用; 缺点: 一般计算机都会部署其他的应用服务,如果该功能函数模型无法满足/时间和数据量的,个人还是不建议使用并行化; 总结 并行并不一定比串行快,具体业务具体分析; 并发模型与分布式系统的相似性并发系统 : 不同的线程彼此之间通信, 分布式系统: 不同的进程相互之间通信 总结 线程和进程本质上非常相似.]]></content>
  </entry>
</search>
